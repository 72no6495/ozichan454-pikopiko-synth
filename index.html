<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ozichan454-pikopiko-synth v2</title>
    <style>
        :root {
            --bg-grad-start: #0f0c29;
            --bg-grad-mid: #302b63;
            --bg-grad-end: #24243e;
            --primary-color: #00ffcc; /* Cyan for accents */
            --secondary-color: #d500f9; /* Neon Purple */
            --glass-bg: rgba(255, 255, 255, 0.05);
            --border-color: rgba(255, 255, 255, 0.2);
        }

        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--bg-grad-start), var(--bg-grad-mid), var(--bg-grad-end));
            color: #fff;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            user-select: none;
            padding: 20px 0;
        }

        h1 {
            text-shadow: 0 0 10px var(--secondary-color);
            margin: 10px 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-align: center;
        }

        /* --- Main Container --- */
        .synth-container {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5), 0 0 10px var(--secondary-color);
            width: 95%;
            max-width: 850px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- Visualizer Area --- */
        .visualizer-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            width: 100%;
            height: 120px;
        }

        .side-image-wrapper {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 2px solid var(--primary-color);
            overflow: hidden;
            box-shadow: 0 0 15px var(--primary-color), inset 0 0 10px #000;
            flex-shrink: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .side-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.05s ease-out; 
            will-change: transform;
        }
        
        .side-image-wrapper::after {
            content: 'No IMG';
            position: absolute;
            font-size: 0.6rem;
            color: #555;
            z-index: -1;
        }

        .visualizer-frame {
            flex-grow: 1;
            height: 100%;
            background: #000;
            border: 2px solid #333;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 20px #000;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* --- Controls --- */
        .controls-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.7rem;
            color: var(--primary-color);
            text-transform: uppercase;
            white-space: nowrap;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
            margin: 5px 0;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            margin-top: -5px;
            box-shadow: 0 0 8px var(--secondary-color);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #444;
            border-radius: 2px;
        }

        select {
            background: #222;
            color: #fff;
            border: 1px solid var(--primary-color);
            padding: 4px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
        }
        select:hover {
            box-shadow: 0 0 5px var(--primary-color);
        }

        /* --- Drum Pads --- */
        .pads-area {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 5px;
        }

        .pad-btn {
            background: #333;
            border: 1px solid var(--border-color);
            color: var(--primary-color);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.8rem;
            transition: all 0.1s;
            text-shadow: 0 0 5px var(--primary-color);
            flex: 1;
            max-width: 150px;
        }

        .pad-btn:active {
            background: var(--primary-color);
            color: #000;
            transform: scale(0.97);
            box-shadow: 0 0 15px var(--primary-color);
        }

        /* --- Keyboard --- */
        .keyboard {
            display: flex;
            justify-content: center;
            position: relative;
            height: 120px;
            margin-top: 10px;
        }

        .key {
            position: relative;
            flex: 1;
            max-width: 40px;
            height: 100%;
            background: white;
            border: 1px solid #ccc;
            border-radius: 0 0 5px 5px;
            margin: 0 2px;
            cursor: pointer;
            z-index: 1;
            transition: background 0.1s;
        }

        .key.black {
            max-width: 28px;
            height: 60%;
            background: #111;
            border: 1px solid #000;
            margin-left: -16px;
            margin-right: -16px;
            z-index: 2;
        }

        .key:active, .key.active {
            background: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color);
            transform: translateY(2px);
        }
        .key.black:active, .key.black.active {
            background: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color);
        }

        /* Overlay */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }
        #start-overlay h2 {
            color: var(--primary-color);
            animation: pulse 1.5s infinite;
            font-size: 2rem;
        }

        @keyframes pulse {
            0% { opacity: 0.6; text-shadow: 0 0 10px var(--primary-color); }
            50% { opacity: 1; text-shadow: 0 0 30px var(--primary-color), 0 0 10px #fff; }
            100% { opacity: 0.6; text-shadow: 0 0 10px var(--primary-color); }
        }

        @media (max-width: 600px) {
            .side-image-wrapper {
                width: 50px;
                height: 50px;
            }
            .visualizer-container {
                gap: 8px;
                height: 90px;
            }
            .controls-area { grid-template-columns: 1fr 1fr; }
            .keyboard { height: 100px; }
            h1 { font-size: 1.2rem; }
        }
    </style>
</head>
<body>

    <div id="start-overlay">
        <h2>CLICK TO START</h2>
        <p>Sound & Advanced Visuals Init</p>
    </div>

    <h1>OZICHAN454 PIKOPIKO SYNTH V2</h1>

    <div class="synth-container">
        
        <div class="visualizer-container">
            <div class="side-image-wrapper left">
                <img src="profile.jpg" alt="L" class="side-image" id="img-left" onerror="this.style.display='none'">
            </div>

            <div class="visualizer-frame">
                <canvas id="visualizer"></canvas>
                <div class="screen-overlay"></div>
            </div>

            <div class="side-image-wrapper right">
                <img src="profile.jpg" alt="R" class="side-image" id="img-right" onerror="this.style.display='none'">
            </div>
        </div>

        <div class="controls-area">
            <div class="control-group">
                <label for="visualizer-mode">Visual Mode</label>
                <select id="visualizer-mode">
                    <option value="wave">Neon Wave (Line)</option>
                    <option value="bars">Spectrum Bars</option>
                    <option value="circle">Cyber Circle</option>
                    <option value="symmetry">Symmetry (Trippy)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="waveform">Waveform</label>
                <select id="waveform">
                    <option value="square">Square (8bit)</option>
                    <option value="sawtooth">Sawtooth (Sharp)</option>
                    <option value="triangle">Triangle (Soft)</option>
                    <option value="sine">Sine (Pure)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="volume">Master Vol</label>
                <input type="range" id="volume" min="0" max="1" step="0.01" value="0.4">
            </div>

            <div class="control-group">
                <label for="detune">Detune</label>
                <input type="range" id="detune" min="0" max="50" step="1" value="5">
            </div>

            <div class="control-group">
                <label for="attack">Attack</label>
                <input type="range" id="attack" min="0.001" max="1" step="0.005" value="0.02">
            </div>

            <div class="control-group">
                <label for="decay">Release</label>
                <input type="range" id="decay" min="0.1" max="3" step="0.1" value="0.5">
            </div>
        </div>

        <div class="pads-area">
            <button class="pad-btn" id="btn-kick">KICK (Bass)</button>
            <button class="pad-btn" id="btn-crash">CRASH (Noise)</button>
        </div>

        <div class="keyboard" id="keyboard"></div>
        <div style="text-align:center; font-size: 0.6rem; color: #888; margin-top:5px;">
            PC Keys: Z S X D C V G B H N J M , (Shift=High Octave)
        </div>
    </div>

    <script>
        /**
         * CYBERTUNE SYNTH ENGINE V2 + ADVANCED VISUALIZER
         */

        // 1. Setup & Elements
        let audioCtx, masterGain, analyser, isInit = false;
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        
        // Image Elements
        const imgLeft = document.getElementById('img-left');
        const imgRight = document.getElementById('img-right');

        // UI Controls
        const visualizerSelect = document.getElementById('visualizer-mode');
        const volumeSlider = document.getElementById('volume');
        const waveformSelect = document.getElementById('waveform');
        const detuneSlider = document.getElementById('detune');
        const attackSlider = document.getElementById('attack');
        const decaySlider = document.getElementById('decay');
        
        // Keyboard Data
        const notes = [
            { note: 'C', type: 'white', freq: 261.63, key: 'z' },
            { note: 'C#', type: 'black', freq: 277.18, key: 's' },
            { note: 'D', type: 'white', freq: 293.66, key: 'x' },
            { note: 'D#', type: 'black', freq: 311.13, key: 'd' },
            { note: 'E', type: 'white', freq: 329.63, key: 'c' },
            { note: 'F', type: 'white', freq: 349.23, key: 'v' },
            { note: 'F#', type: 'black', freq: 369.99, key: 'g' },
            { note: 'G', type: 'white', freq: 392.00, key: 'b' },
            { note: 'G#', type: 'black', freq: 415.30, key: 'h' },
            { note: 'A', type: 'white', freq: 440.00, key: 'n' },
            { note: 'A#', type: 'black', freq: 466.16, key: 'j' },
            { note: 'B', type: 'white', freq: 493.88, key: 'm' },
            { note: 'C5', type: 'white', freq: 523.25, key: ',' }
        ];
        const keyMap = {};
        notes.forEach(n => keyMap[n.key] = n.freq);

        // --- Initialization ---
        function initAudio() {
            if (isInit) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            masterGain = audioCtx.createGain();
            masterGain.gain.value = volumeSlider.value;

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048; // Resolution

            masterGain.connect(analyser);
            analyser.connect(audioCtx.destination);

            isInit = true;
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 500);
            
            drawLoop(); 
        }

        // --- Sound Generation (Synth) ---
        function playNote(freq) {
            if (!isInit) initAudio();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = waveformSelect.value;
            osc.frequency.setValueAtTime(freq, now);

            let osc2 = null;
            let detuneVal = parseInt(detuneSlider.value);
            if (detuneVal > 0) {
                osc2 = audioCtx.createOscillator();
                osc2.type = waveformSelect.value;
                osc2.frequency.setValueAtTime(freq, now);
                osc2.detune.value = detuneVal; 
                osc2.start(now);
            }

            const noteGain = audioCtx.createGain();
            const attack = parseFloat(attackSlider.value);
            
            noteGain.gain.setValueAtTime(0, now);
            noteGain.gain.setTargetAtTime(1, now, attack / 3);
            
            osc.connect(noteGain);
            if (osc2) osc2.connect(noteGain);
            noteGain.connect(masterGain);
            osc.start(now);

            return { osc, osc2, noteGain };
        }

        function stopNote(noteObj) {
            if (!noteObj || !noteObj.noteGain) return;
            const now = audioCtx.currentTime;
            const release = parseFloat(decaySlider.value);

            noteObj.noteGain.gain.cancelScheduledValues(now);
            noteObj.noteGain.gain.setValueAtTime(noteObj.noteGain.gain.value, now);
            noteObj.noteGain.gain.exponentialRampToValueAtTime(0.001, now + release);

            const stopTime = now + release + 0.1;
            noteObj.osc.stop(stopTime);
            if (noteObj.osc2) noteObj.osc2.stop(stopTime);
        }

        // --- Sound Generation (Drums) ---
        function playKick() {
            if (!isInit) initAudio();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(masterGain);
            osc.frequency.setValueAtTime(180, now);
            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.4);
            gain.gain.setValueAtTime(1.2, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            osc.start(now);
            osc.stop(now + 0.4);
        }

        function playCrash() {
            if (!isInit) initAudio();
            const now = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 1.5;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1200;
            const gain = audioCtx.createGain();
            noise.connect(filter).connect(gain).connect(masterGain);
            gain.gain.setValueAtTime(1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            noise.start(now);
        }

        // --- Visualizer Logic ---

        function drawLoop() {
            requestAnimationFrame(drawLoop);

            const bufferLength = analyser.frequencyBinCount;
            // 振動計算用（常にTimeDomainDataが必要）
            const dataArrayTime = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArrayTime);

            // 1. Shaking Logic (共通)
            applyShakeEffect(dataArrayTime);

            // 2. Clear Canvas
            const width = canvas.width = canvas.parentElement.offsetWidth;
            const height = canvas.height = canvas.parentElement.offsetHeight;
            
            // 残像効果
            canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            canvasCtx.fillRect(0, 0, width, height);

            // 3. Draw Selected Visualizer
            const mode = visualizerSelect.value;
            
            if (mode === 'wave') {
                drawWaveform(dataArrayTime, width, height);
            } else if (mode === 'bars') {
                const dataArrayFreq = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArrayFreq);
                drawSpectrumBars(dataArrayFreq, width, height);
            } else if (mode === 'circle') {
                const dataArrayFreq = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArrayFreq);
                drawCyberCircle(dataArrayFreq, width, height, dataArrayTime);
            } else if (mode === 'symmetry') {
                drawSymmetry(dataArrayTime, width, height);
            }
        }

        // --- Shaking Effect Implementation ---
        function applyShakeEffect(dataArray) {
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += Math.abs(dataArray[i] - 128);
            }
            const avg = sum / dataArray.length;
            const shakeIntensity = avg * 0.3; 
            const scaleFactor = 1 + (avg / 128) * 0.15;

            const xOff = (Math.random() * 2 - 1) * shakeIntensity;
            const yOff = (Math.random() * 2 - 1) * shakeIntensity;

            const transformStyle = `translate(${xOff.toFixed(1)}px, ${yOff.toFixed(1)}px) scale(${scaleFactor.toFixed(2)})`;
            
            imgLeft.style.transform = transformStyle;
            imgRight.style.transform = `translate(${-xOff.toFixed(1)}px, ${-yOff.toFixed(1)}px) scale(${scaleFactor.toFixed(2)})`;
        }

        // --- Drawing Algorithms ---

        // Mode 1: Neon Wave (Original + Glow)
        function drawWaveform(data, w, h) {
            canvasCtx.lineWidth = 3;
            canvasCtx.strokeStyle = '#00ffcc';
            canvasCtx.shadowBlur = 15;
            canvasCtx.shadowColor = '#00ffcc';
            canvasCtx.beginPath();

            const sliceWidth = w * 1.0 / data.length;
            let x = 0;

            for (let i = 0; i < data.length; i++) {
                const v = data[i] / 128.0;
                const y = v * h / 2;
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
                x += sliceWidth;
            }
            canvasCtx.lineTo(w, h / 2);
            canvasCtx.stroke();
        }

        // Mode 2: Spectrum Bars
        function drawSpectrumBars(data, w, h) {
            const barCount = 64; // 間引きして表示
            const step = Math.floor(data.length / barCount);
            const barWidth = (w / barCount) - 2;

            for (let i = 0; i < barCount; i++) {
                const value = data[i * step];
                const percent = value / 255;
                const barHeight = percent * h;
                
                // Color Gradient based on height
                const hue = 180 + (percent * 120); // Cyan to Purple
                canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                canvasCtx.shadowBlur = 10;
                canvasCtx.shadowColor = `hsl(${hue}, 100%, 50%)`;

                canvasCtx.fillRect(i * (barWidth + 2), h - barHeight, barWidth, barHeight);
            }
        }

        // Mode 3: Cyber Circle
        function drawCyberCircle(data, w, h, timeData) {
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) / 3.5;

            // Base Circle
            canvasCtx.beginPath();
            canvasCtx.arc(cx, cy, radius, 0, Math.PI * 2);
            canvasCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            canvasCtx.stroke();

            // Frequency bars radiating out
            const barCount = 40;
            const step = Math.floor(data.length / barCount);
            
            for (let i = 0; i < barCount; i++) {
                const value = data[i * step];
                const percent = value / 255;
                const length = percent * (radius * 0.8);
                const angle = (Math.PI * 2 * i) / barCount;

                const x1 = cx + Math.cos(angle) * radius;
                const y1 = cy + Math.sin(angle) * radius;
                const x2 = cx + Math.cos(angle) * (radius + length);
                const y2 = cy + Math.sin(angle) * (radius + length);

                canvasCtx.strokeStyle = `hsl(${280 - percent * 100}, 100%, 60%)`; // Purple to Cyan
                canvasCtx.lineWidth = 4;
                canvasCtx.beginPath();
                canvasCtx.moveTo(x1, y1);
                canvasCtx.lineTo(x2, y2);
                canvasCtx.stroke();
            }

            // Inner Wave (Time Domain)
            canvasCtx.beginPath();
            canvasCtx.strokeStyle = '#fff';
            canvasCtx.lineWidth = 2;
            for(let i=0; i<timeData.length; i+=10) {
                const v = (timeData[i] - 128) / 128; // -1 to 1
                const r = radius * 0.6 + (v * 20);
                const angle = (Math.PI * 2 * i) / timeData.length;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                if(i===0) canvasCtx.moveTo(x,y);
                else canvasCtx.lineTo(x,y);
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
        }

        // Mode 4: Symmetry (Rorschach Style)
        function drawSymmetry(data, w, h) {
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#d500f9'; // Neon Purple
            canvasCtx.shadowBlur = 10;
            canvasCtx.shadowColor = '#00ffcc'; // Cyan Glow
            
            const cx = w / 2;
            const cy = h / 2;

            canvasCtx.beginPath();
            
            // Draw half, mirror it
            for (let i = 0; i < data.length; i+=5) {
                const v = (data[i] - 128) * 1.5; // Amplify
                const x = (i / data.length) * (w / 2); // Use half width
                
                // Top Right
                if (i===0) canvasCtx.moveTo(cx + x, cy - v);
                else canvasCtx.lineTo(cx + x, cy - v);
            }
            canvasCtx.stroke();

            // Mirror Logic via transforms context logic is complex, simpler to just redraw loop for mirror parts?
            // Let's use loop for stability.
            
            // Bottom Right
            canvasCtx.beginPath();
            for (let i = 0; i < data.length; i+=5) {
                const v = (data[i] - 128) * 1.5;
                const x = (i / data.length) * (w / 2);
                if (i===0) canvasCtx.moveTo(cx + x, cy + v);
                else canvasCtx.lineTo(cx + x, cy + v);
            }
            canvasCtx.stroke();

            // Top Left
            canvasCtx.beginPath();
            for (let i = 0; i < data.length; i+=5) {
                const v = (data[i] - 128) * 1.5;
                const x = (i / data.length) * (w / 2);
                if (i===0) canvasCtx.moveTo(cx - x, cy - v);
                else canvasCtx.lineTo(cx - x, cy - v);
            }
            canvasCtx.stroke();

            // Bottom Left
            canvasCtx.beginPath();
            for (let i = 0; i < data.length; i+=5) {
                const v = (data[i] - 128) * 1.5;
                const x = (i / data.length) * (w / 2);
                if (i===0) canvasCtx.moveTo(cx - x, cy + v);
                else canvasCtx.lineTo(cx - x, cy + v);
            }
            canvasCtx.stroke();
        }


        // --- Input Handling ---
        volumeSlider.addEventListener('input', (e) => { if(masterGain) masterGain.gain.value = e.target.value; });

        // Generate Keyboard UI
        const keyboardDiv = document.getElementById('keyboard');
        notes.forEach(n => {
            const k = document.createElement('div');
            k.className = `key ${n.type}`;
            k.dataset.key = n.key;
            
            const start = (e) => { e.preventDefault(); k.classList.add('active'); k.activeTone = playNote(n.freq); };
            const end = (e) => { e.preventDefault(); k.classList.remove('active'); stopNote(k.activeTone); };

            k.addEventListener('mousedown', start);
            k.addEventListener('mouseup', end);
            k.addEventListener('mouseleave', end);
            k.addEventListener('touchstart', start, {passive:false});
            k.addEventListener('touchend', end, {passive:false});
            keyboardDiv.appendChild(k);
        });

        // Physical Keyboard
        let activeKeys = {};
        document.addEventListener('keydown', (e) => {
            if (!isInit || e.repeat) return;
            const key = e.key.toLowerCase();
            if (keyMap[key]) {
                const domKey = document.querySelector(`.key[data-key="${key}"]`);
                if(domKey) domKey.classList.add('active');
                let freq = keyMap[key];
                if (e.shiftKey) freq *= 2;
                activeKeys[key] = playNote(freq);
            }
        });
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (activeKeys[key]) {
                stopNote(activeKeys[key]);
                const domKey = document.querySelector(`.key[data-key="${key}"]`);
                if(domKey) domKey.classList.remove('active');
                delete activeKeys[key];
            }
        });

        // Drums
        const kickBtn = document.getElementById('btn-kick');
        const crashBtn = document.getElementById('btn-crash');
        kickBtn.addEventListener('mousedown', playKick);
        crashBtn.addEventListener('mousedown', playCrash);
        kickBtn.addEventListener('touchstart', (e)=>{e.preventDefault();playKick()}, {passive:false});
        crashBtn.addEventListener('touchstart', (e)=>{e.preventDefault();playCrash()}, {passive:false});

        // Start Click
        document.getElementById('start-overlay').addEventListener('click', initAudio);

    </script>
</body>
</html>
